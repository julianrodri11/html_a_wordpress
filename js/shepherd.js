!function (global, factory) { "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : (global = global || self).Shepherd = factory() }(this, function () { "use strict"; function baseSlice(array, start, end) { var index = -1, length = array.length; start < 0 && (start = -start > length ? 0 : length + start), (end = end > length ? length : end) < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0; for (var result = Array(length); ++index < length;)result[index] = array[index + start]; return result } function isObject(value) { var type = typeof value; return null != value && ("object" == type || "function" == type) } var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol = root.Symbol, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol ? Symbol.toStringTag : void 0; function getRawTag(value) { var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag]; try { value[symToStringTag] = void 0; var unmasked = !0 } catch (e) { } var result = nativeObjectToString.call(value); return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result } var objectProto, nativeObjectToString = Object.prototype.toString; function objectToString(value) { return nativeObjectToString.call(value) } var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol ? Symbol.toStringTag : void 0; function baseGetTag(value) { return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value) } function isObjectLike(value) { return null != value && "object" == typeof value } var symbolTag = "[object Symbol]"; function isSymbol(value) { return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag } var NAN = NaN, reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt; function toNumber(value) { if ("number" == typeof value) return value; if (isSymbol(value)) return NAN; if (isObject(value)) { var other = "function" == typeof value.valueOf ? value.valueOf() : value; value = isObject(other) ? other + "" : other } if ("string" != typeof value) return 0 === value ? value : +value; value = value.replace(reTrim, ""); var isBinary = reIsBinary.test(value); return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value } var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e308; function toFinite(value) { return value ? (value = toNumber(value)) === INFINITY || value === -INFINITY ? (value < 0 ? -1 : 1) * MAX_INTEGER : value == value ? value : 0 : 0 === value ? value : 0; var sign } function toInteger(value) { var result = toFinite(value), remainder = result % 1; return result == result ? remainder ? result - remainder : result : 0 } function drop(array, n, guard) { var length = null == array ? 0 : array.length; return length ? baseSlice(array, (n = guard || void 0 === n ? 1 : toInteger(n)) < 0 ? 0 : n, length) : [] } function isUndefined(value) { return void 0 === value } class Evented { on(event, handler, ctx) { const once = !(arguments.length <= 3 || void 0 === arguments[3]) && arguments[3]; isUndefined(this.bindings) && (this.bindings = {}), isUndefined(this.bindings[event]) && (this.bindings[event] = []), this.bindings[event].push({ handler: handler, ctx: ctx, once: once }) } once(event, handler, ctx) { this.on(event, handler, ctx, !0) } off(event, handler) { if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) return !1; isUndefined(handler) ? delete this.bindings[event] : this.bindings[event].forEach((binding, index) => { binding.handler === handler && this.bindings[event].splice(index, 1) }) } trigger(event) { if (!isUndefined(this.bindings) && this.bindings[event]) { const args = drop(arguments); this.bindings[event].forEach((binding, index) => { const ctx = binding.ctx, handler = binding.handler, once = binding.once, context = ctx || this; handler.apply(context, args), once && this.bindings[event].splice(index, 1) }) } } } function createBaseFor(fromRight) { return function (object, iteratee, keysFunc) { for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--;) { var key = props[fromRight ? length : ++index]; if (!1 === iteratee(iterable[key], key, iterable)) break } return object } } var baseFor = createBaseFor(); function baseTimes(n, iteratee) { for (var index = -1, result = Array(n); ++index < n;)result[index] = iteratee(index); return result } var argsTag = "[object Arguments]"; function baseIsArguments(value) { return isObjectLike(value) && baseGetTag(value) == argsTag } var objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(function () { return arguments }()) ? baseIsArguments : function (value) { return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") }, isArray = Array.isArray; function stubFalse() { return !1 } var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports, Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, nativeIsBuffer, isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse, MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/; function isIndex(value, length) { var type = typeof value; return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length } var MAX_SAFE_INTEGER = 9007199254740991; function isLength(value) { return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER } var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag, float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {}; function baseIsTypedArray(value) { return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)] } function baseUnary(func) { return function (value) { return func(value) } } typedArrayTags["[object Float32Array]"] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1; var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports, freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process, nodeUtil = function () { try { var types = freeModule && freeModule.require && freeModule.require("util").types; return types || freeProcess && freeProcess.binding && freeProcess.binding("util") } catch (e) { } }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto, hasOwnProperty = Object.prototype.hasOwnProperty; function arrayLikeKeys(value, inherited) { var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key); return result } var objectProto = Object.prototype; function isPrototype(value) { var Ctor = value && value.constructor, proto; return value === ("function" == typeof Ctor && Ctor.prototype || objectProto) } function overArg(func, transform) { return function (arg) { return func(transform(arg)) } } var nativeKeys = overArg(Object.keys, Object), objectProto, hasOwnProperty = Object.prototype.hasOwnProperty; function baseKeys(object) { if (!isPrototype(object)) return nativeKeys(object); var result = []; for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key); return result } var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]"; function isFunction(value) { if (!isObject(value)) return !1; var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag } function isArrayLike(value) { return null != value && isLength(value.length) && !isFunction(value) } function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object) } function baseForOwn(object, iteratee) { return object && baseFor(object, iteratee, keys) } function identity(value) { return value } function castFunction(value) { return "function" == typeof value ? value : identity } function forOwn(object, iteratee) { return object && baseForOwn(object, castFunction(iteratee)) } var getPrototype = overArg(Object.getPrototypeOf, Object), objectTag = "[object Object]", funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object); function isPlainObject(value) { if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1; var proto = getPrototype(value); if (null === proto) return !0; var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor; return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString } function isElement(value) { return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value) } var coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", uid; function isMasked(func) { return !!maskSrcKey && maskSrcKey in func } var funcProto, funcToString = Function.prototype.toString; function toSource(func) { if (null != func) { try { return funcToString.call(func) } catch (e) { } try { return func + "" } catch (e) { } } return "" } var reRegExpChar = /[\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\$&").replace(/hasOwnProperty|(function).*?(?=\\()| for .+?(?=\\])/g, ".*?") + "$"); function baseIsNative(value) { return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value)); var pattern } function getValue(object, key) { return null == object ? void 0 : object[key] } function getNative(object, key) { var value = getValue(object, key); return baseIsNative(value) ? value : void 0 } var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag = "[object DataView]", dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), getTag = baseGetTag; (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function (value) { var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : ""; if (ctorString) switch (ctorString) { case dataViewCtorString: return dataViewTag; case mapCtorString: return mapTag; case promiseCtorString: return promiseTag; case setCtorString: return setTag; case weakMapCtorString: return weakMapTag }return result }); var getTag = getTag, mapTag = "[object Map]", setTag = "[object Set]", objectProto, hasOwnProperty = Object.prototype.hasOwnProperty; function isEmpty(value) { if (null == value) return !0; if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length; var tag = getTag(value); if (tag == mapTag || tag == setTag) return !value.size; if (isPrototype(value)) return !baseKeys(value).length; for (var key in value) if (hasOwnProperty.call(value, key)) return !1; return !0 } var stringTag = "[object String]"; function isString(value) { return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag } function _defineProperty(obj, key, value) { return key in obj ? Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj } function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}, ownKeys = Object.keys(source); "function" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable }))), ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]) }) } return target } function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest() } function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr } function _iterableToArrayLimit(arr, i) { var _arr = [], _n = !0, _d = !1, _e = void 0; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i || _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err } finally { try { _n || null == _i.return || _i.return() } finally { if (_d) throw _e } } return _arr } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance") } Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector); var defineProperty = function () { try { var func = getNative(Object, "defineProperty"); return func({}, "", {}), func } catch (e) { } }(); function baseAssignValue(object, key, value) { "__proto__" == key && defineProperty ? defineProperty(object, key, { configurable: !0, enumerable: !0, value: value, writable: !0 }) : object[key] = value } function eq(value, other) { return value === other || value != value && other != other } var objectProto, hasOwnProperty = Object.prototype.hasOwnProperty; function assignValue(object, key, value) { var objValue = object[key]; hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || baseAssignValue(object, key, value) } function baseZipObject(props, values, assignFunc) { for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length;) { var value = index < valsLength ? values[index] : void 0; assignFunc(result, props[index], value) } return result } function zipObject(props, values) { return baseZipObject(props || [], values || [], assignValue) } for (var isBrowser = "undefined" != typeof window && "undefined" != typeof document, longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"], timeoutDuration = 0, i = 0; i < longerTimeoutBrowsers.length; i += 1)if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) { timeoutDuration = 1; break } function microtaskDebounce(fn) { var called = !1; return function () { called || (called = !0, window.Promise.resolve().then(function () { called = !1, fn() })) } } function taskDebounce(fn) { var scheduled = !1; return function () { scheduled || (scheduled = !0, setTimeout(function () { scheduled = !1, fn() }, timeoutDuration)) } } var supportsMicroTasks, debounce = isBrowser && window.Promise ? microtaskDebounce : taskDebounce; function isFunction(functionToCheck) { var getType; return functionToCheck && "[object Function]" === {}.toString.call(functionToCheck) } function getStyleComputedProperty(element, property) { if (1 !== element.nodeType) return []; var window, css = element.ownerDocument.defaultView.getComputedStyle(element, null); return property ? css[property] : css } function getParentNode(element) { return "HTML" === element.nodeName ? element : element.parentNode || element.host } function getScrollParent(element) { if (!element) return document.body; switch (element.nodeName) { case "HTML": case "BODY": return element.ownerDocument.body; case "#document": return element.body }var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY; return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX) ? element : getScrollParent(getParentNode(element)) } var isIE11 = isBrowser && !(!window.MSInputMethodContext || !document.documentMode), isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent); function isIE(version) { return 11 === version ? isIE11 : 10 === version ? isIE10 : isIE11 || isIE10 } function getOffsetParent(element) { if (!element) return document.documentElement; for (var noOffsetParent = isIE(10) ? document.body : null, offsetParent = element.offsetParent || null; offsetParent === noOffsetParent && element.nextElementSibling;)offsetParent = (element = element.nextElementSibling).offsetParent; var nodeName = offsetParent && offsetParent.nodeName; return nodeName && "BODY" !== nodeName && "HTML" !== nodeName ? -1 !== ["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) && "static" === getStyleComputedProperty(offsetParent, "position") ? getOffsetParent(offsetParent) : offsetParent : element ? element.ownerDocument.documentElement : document.documentElement } function isOffsetContainer(element) { var nodeName = element.nodeName; return "BODY" !== nodeName && ("HTML" === nodeName || getOffsetParent(element.firstElementChild) === element) } function getRoot(node) { return null !== node.parentNode ? getRoot(node.parentNode) : node } function findCommonOffsetParent(element1, element2) { if (!(element1 && element1.nodeType && element2 && element2.nodeType)) return document.documentElement; var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING, start = order ? element1 : element2, end = order ? element2 : element1, range = document.createRange(); range.setStart(start, 0), range.setEnd(end, 0); var commonAncestorContainer = range.commonAncestorContainer; if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) return isOffsetContainer(commonAncestorContainer) ? commonAncestorContainer : getOffsetParent(commonAncestorContainer); var element1root = getRoot(element1); return element1root.host ? findCommonOffsetParent(element1root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host) } function getScroll(element) { var side, upperSide = "top" === (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "top") ? "scrollTop" : "scrollLeft", nodeName = element.nodeName; if ("BODY" === nodeName || "HTML" === nodeName) { var html = element.ownerDocument.documentElement, scrollingElement; return (element.ownerDocument.scrollingElement || html)[upperSide] } return element[upperSide] } function includeScroll(rect, element) { var subtract = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], scrollTop = getScroll(element, "top"), scrollLeft = getScroll(element, "left"), modifier = subtract ? -1 : 1; return rect.top += scrollTop * modifier, rect.bottom += scrollTop * modifier, rect.left += scrollLeft * modifier, rect.right += scrollLeft * modifier, rect } function getBordersSize(styles, axis) { var sideA = "x" === axis ? "Left" : "Top", sideB = "Left" === sideA ? "Right" : "Bottom"; return parseFloat(styles["border" + sideA + "Width"], 10) + parseFloat(styles["border" + sideB + "Width"], 10) } function getSize(axis, body, html, computedStyle) { return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + ("Height" === axis ? "Top" : "Left")]) + parseInt(computedStyle["margin" + ("Height" === axis ? "Bottom" : "Right")]) : 0) } function getWindowSizes(document) { var body = document.body, html = document.documentElement, computedStyle = isIE(10) && getComputedStyle(html); return { height: getSize("Height", body, html, computedStyle), width: getSize("Width", body, html, computedStyle) } } var classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function") }, createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } return function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor } }(), defineProperty = function (obj, key, value) { return key in obj ? Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj }, _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]) } return target }; function getClientRect(offsets) { return _extends({}, offsets, { right: offsets.left + offsets.width, bottom: offsets.top + offsets.height }) } function getBoundingClientRect(element) { var rect = {}; try { if (isIE(10)) { rect = element.getBoundingClientRect(); var scrollTop = getScroll(element, "top"), scrollLeft = getScroll(element, "left"); rect.top += scrollTop, rect.left += scrollLeft, rect.bottom += scrollTop, rect.right += scrollLeft } else rect = element.getBoundingClientRect() } catch (e) { } var result = { left: rect.left, top: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top }, sizes = "HTML" === element.nodeName ? getWindowSizes(element.ownerDocument) : {}, width = sizes.width || element.clientWidth || result.right - result.left, height = sizes.height || element.clientHeight || result.bottom - result.top, horizScrollbar = element.offsetWidth - width, vertScrollbar = element.offsetHeight - height; if (horizScrollbar || vertScrollbar) { var styles = getStyleComputedProperty(element); horizScrollbar -= getBordersSize(styles, "x"), vertScrollbar -= getBordersSize(styles, "y"), result.width -= horizScrollbar, result.height -= vertScrollbar } return getClientRect(result) } function getOffsetRectRelativeToArbitraryNode(children, parent) { var fixedPosition = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], isIE10 = isIE(10), isHTML = "HTML" === parent.nodeName, childrenRect = getBoundingClientRect(children), parentRect = getBoundingClientRect(parent), scrollParent = getScrollParent(children), styles = getStyleComputedProperty(parent), borderTopWidth = parseFloat(styles.borderTopWidth, 10), borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); fixedPosition && isHTML && (parentRect.top = Math.max(parentRect.top, 0), parentRect.left = Math.max(parentRect.left, 0)); var offsets = getClientRect({ top: childrenRect.top - parentRect.top - borderTopWidth, left: childrenRect.left - parentRect.left - borderLeftWidth, width: childrenRect.width, height: childrenRect.height }); if (offsets.marginTop = 0, offsets.marginLeft = 0, !isIE10 && isHTML) { var marginTop = parseFloat(styles.marginTop, 10), marginLeft = parseFloat(styles.marginLeft, 10); offsets.top -= borderTopWidth - marginTop, offsets.bottom -= borderTopWidth - marginTop, offsets.left -= borderLeftWidth - marginLeft, offsets.right -= borderLeftWidth - marginLeft, offsets.marginTop = marginTop, offsets.marginLeft = marginLeft } return (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && "BODY" !== scrollParent.nodeName) && (offsets = includeScroll(offsets, parent)), offsets } function getViewportOffsetRectRelativeToArtbitraryNode(element) { var excludeScroll = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], html = element.ownerDocument.documentElement, relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html), width = Math.max(html.clientWidth, window.innerWidth || 0), height = Math.max(html.clientHeight, window.innerHeight || 0), scrollTop = excludeScroll ? 0 : getScroll(html), scrollLeft = excludeScroll ? 0 : getScroll(html, "left"), offset; return getClientRect({ top: scrollTop - relativeOffset.top + relativeOffset.marginTop, left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft, width: width, height: height }) } function isFixed(element) { var nodeName = element.nodeName; if ("BODY" === nodeName || "HTML" === nodeName) return !1; if ("fixed" === getStyleComputedProperty(element, "position")) return !0; var parentNode = getParentNode(element); return !!parentNode && isFixed(parentNode) } function getFixedPositionOffsetParent(element) { if (!element || !element.parentElement || isIE()) return document.documentElement; for (var el = element.parentElement; el && "none" === getStyleComputedProperty(el, "transform");)el = el.parentElement; return el || document.documentElement } function getBoundaries(popper, reference, padding, boundariesElement) { var fixedPosition = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], boundaries = { top: 0, left: 0 }, offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); if ("viewport" === boundariesElement) boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition); else { var boundariesNode = void 0; "scrollParent" === boundariesElement ? "BODY" === (boundariesNode = getScrollParent(getParentNode(reference))).nodeName && (boundariesNode = popper.ownerDocument.documentElement) : boundariesNode = "window" === boundariesElement ? popper.ownerDocument.documentElement : boundariesElement; var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); if ("HTML" !== boundariesNode.nodeName || isFixed(offsetParent)) boundaries = offsets; else { var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width; boundaries.top += offsets.top - offsets.marginTop, boundaries.bottom = height + offsets.top, boundaries.left += offsets.left - offsets.marginLeft, boundaries.right = width + offsets.left } } var isPaddingNumber = "number" == typeof (padding = padding || 0); return boundaries.left += isPaddingNumber ? padding : padding.left || 0, boundaries.top += isPaddingNumber ? padding : padding.top || 0, boundaries.right -= isPaddingNumber ? padding : padding.right || 0, boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0, boundaries } function getArea(_ref) { var width, height; return _ref.width * _ref.height } function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) { var padding = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (-1 === placement.indexOf("auto")) return placement; var boundaries = getBoundaries(popper, reference, padding, boundariesElement), rects = { top: { width: boundaries.width, height: refRect.top - boundaries.top }, right: { width: boundaries.right - refRect.right, height: boundaries.height }, bottom: { width: boundaries.width, height: boundaries.bottom - refRect.bottom }, left: { width: refRect.left - boundaries.left, height: boundaries.height } }, sortedAreas = Object.keys(rects).map(function (key) { return _extends({ key: key }, rects[key], { area: getArea(rects[key]) }) }).sort(function (a, b) { return b.area - a.area }), filteredAreas = sortedAreas.filter(function (_ref2) { var width = _ref2.width, height = _ref2.height; return width >= popper.clientWidth && height >= popper.clientHeight }), computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key, variation = placement.split("-")[1]; return computedPlacement + (variation ? "-" + variation : "") } function getReferenceOffsets(state, popper, reference) { var fixedPosition = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, commonOffsetParent; return getOffsetRectRelativeToArbitraryNode(reference, fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference), fixedPosition) } function getOuterSizes(element) { var window, styles = element.ownerDocument.defaultView.getComputedStyle(element), x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0), y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0), result; return { width: element.offsetWidth + y, height: element.offsetHeight + x } } function getOppositePlacement(placement) { var hash = { left: "right", right: "left", bottom: "top", top: "bottom" }; return placement.replace(/left|right|bottom|top/g, function (matched) { return hash[matched] }) } function getPopperOffsets(popper, referenceOffsets, placement) { placement = placement.split("-")[0]; var popperRect = getOuterSizes(popper), popperOffsets = { width: popperRect.width, height: popperRect.height }, isHoriz = -1 !== ["right", "left"].indexOf(placement), mainSide = isHoriz ? "top" : "left", secondarySide = isHoriz ? "left" : "top", measurement = isHoriz ? "height" : "width", secondaryMeasurement = isHoriz ? "width" : "height"; return popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2, popperOffsets[secondarySide] = placement === secondarySide ? referenceOffsets[secondarySide] - popperRect[secondaryMeasurement] : referenceOffsets[getOppositePlacement(secondarySide)], popperOffsets } function find(arr, check) { return Array.prototype.find ? arr.find(check) : arr.filter(check)[0] } function findIndex(arr, prop, value) { if (Array.prototype.findIndex) return arr.findIndex(function (cur) { return cur[prop] === value }); var match = find(arr, function (obj) { return obj[prop] === value }); return arr.indexOf(match) } function runModifiers(modifiers, data, ends) { var modifiersToRun; return (void 0 === ends ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends))).forEach(function (modifier) { modifier.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!"); var fn = modifier.function || modifier.fn; modifier.enabled && isFunction(fn) && (data.offsets.popper = getClientRect(data.offsets.popper), data.offsets.reference = getClientRect(data.offsets.reference), data = fn(data, modifier)) }), data } function update() { if (!this.state.isDestroyed) { var data = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {} }; data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed), data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), data.originalPlacement = data.placement, data.positionFixed = this.options.positionFixed, data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement), data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", data = runModifiers(this.modifiers, data), this.state.isCreated ? this.options.onUpdate(data) : (this.state.isCreated = !0, this.options.onCreate(data)) } } function isModifierEnabled(modifiers, modifierName) { return modifiers.some(function (_ref) { var name = _ref.name, enabled; return _ref.enabled && name === modifierName }) } function getSupportedPropertyName(property) { for (var prefixes = [!1, "ms", "Webkit", "Moz", "O"], upperProp = property.charAt(0).toUpperCase() + property.slice(1), i = 0; i < prefixes.length; i++) { var prefix = prefixes[i], toCheck = prefix ? "" + prefix + upperProp : property; if (void 0 !== document.body.style[toCheck]) return toCheck } return null } function destroy() { return this.state.isDestroyed = !0, isModifierEnabled(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[getSupportedPropertyName("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } function getWindow(element) { var ownerDocument = element.ownerDocument; return ownerDocument ? ownerDocument.defaultView : window } function attachToScrollParents(scrollParent, event, callback, scrollParents) { var isBody = "BODY" === scrollParent.nodeName, target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent; target.addEventListener(event, callback, { passive: !0 }), isBody || attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents), scrollParents.push(target) } function setupEventListeners(reference, options, state, updateBound) { state.updateBound = updateBound, getWindow(reference).addEventListener("resize", state.updateBound, { passive: !0 }); var scrollElement = getScrollParent(reference); return attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents), state.scrollElement = scrollElement, state.eventsEnabled = !0, state } function enableEventListeners() { this.state.eventsEnabled || (this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate)) } function removeEventListeners(reference, state) { return getWindow(reference).removeEventListener("resize", state.updateBound), state.scrollParents.forEach(function (target) { target.removeEventListener("scroll", state.updateBound) }), state.updateBound = null, state.scrollParents = [], state.scrollElement = null, state.eventsEnabled = !1, state } function disableEventListeners() { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = removeEventListeners(this.reference, this.state)) } function isNumeric(n) { return "" !== n && !isNaN(parseFloat(n)) && isFinite(n) } function setStyles(element, styles) { Object.keys(styles).forEach(function (prop) { var unit = ""; -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(prop) && isNumeric(styles[prop]) && (unit = "px"), element.style[prop] = styles[prop] + unit }) } function setAttributes(element, attributes) { Object.keys(attributes).forEach(function (prop) { var value; !1 !== attributes[prop] ? element.setAttribute(prop, attributes[prop]) : element.removeAttribute(prop) }) } function applyStyle(data) { return setStyles(data.instance.popper, data.styles), setAttributes(data.instance.popper, data.attributes), data.arrowElement && Object.keys(data.arrowStyles).length && setStyles(data.arrowElement, data.arrowStyles), data } function applyStyleOnLoad(reference, popper, options, modifierOptions, state) { var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed), placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding); return popper.setAttribute("x-placement", placement), setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" }), options } function getRoundedOffsets(data, shouldRound) { var _data = data.offsets, popper = _data.popper, reference = _data.reference, round = Math.round, floor = Math.floor, noRound = function noRound(v) { return v }, referenceWidth = round(reference.width), popperWidth = round(popper.width), isVertical = -1 !== ["left", "right"].indexOf(data.placement), isVariation = -1 !== data.placement.indexOf("-"), sameWidthParity, bothOddWidth, horizontalToInteger = shouldRound ? isVertical || isVariation || referenceWidth % 2 == popperWidth % 2 ? round : floor : noRound, verticalToInteger = shouldRound ? round : noRound; return { left: horizontalToInteger(referenceWidth % 2 == 1 && popperWidth % 2 == 1 && !isVariation && shouldRound ? popper.left - 1 : popper.left), top: verticalToInteger(popper.top), bottom: verticalToInteger(popper.bottom), right: horizontalToInteger(popper.right) } } var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent); function computeStyle(data, options) { var x = options.x, y = options.y, popper = data.offsets.popper, legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) { return "applyStyle" === modifier.name }).gpuAcceleration; void 0 !== legacyGpuAccelerationOption && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!"); var gpuAcceleration = void 0 !== legacyGpuAccelerationOption ? legacyGpuAccelerationOption : options.gpuAcceleration, offsetParent = getOffsetParent(data.instance.popper), offsetParentRect = getBoundingClientRect(offsetParent), styles = { position: popper.position }, offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox), sideA = "bottom" === x ? "top" : "bottom", sideB = "right" === y ? "left" : "right", prefixedProperty = getSupportedPropertyName("transform"), left = void 0, top = void 0; if (top = "bottom" === sideA ? "HTML" === offsetParent.nodeName ? -offsetParent.clientHeight + offsets.bottom : -offsetParentRect.height + offsets.bottom : offsets.top, left = "right" === sideB ? "HTML" === offsetParent.nodeName ? -offsetParent.clientWidth + offsets.right : -offsetParentRect.width + offsets.right : offsets.left, gpuAcceleration && prefixedProperty) styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)", styles[sideA] = 0, styles[sideB] = 0, styles.willChange = "transform"; else { var invertTop = "bottom" === sideA ? -1 : 1, invertLeft = "right" === sideB ? -1 : 1; styles[sideA] = top * invertTop, styles[sideB] = left * invertLeft, styles.willChange = sideA + ", " + sideB } var attributes = { "x-placement": data.placement }; return data.attributes = _extends({}, attributes, data.attributes), data.styles = _extends({}, styles, data.styles), data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles), data } function isModifierRequired(modifiers, requestingName, requestedName) { var requesting = find(modifiers, function (_ref) { var name; return _ref.name === requestingName }), isRequired = !!requesting && modifiers.some(function (modifier) { return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order }); if (!isRequired) { var _requesting = "`" + requestingName + "`", requested = "`" + requestedName + "`"; console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!") } return isRequired } function arrow(data, options) { var _data; if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) return data; var arrowElement = options.element; if ("string" == typeof arrowElement) { if (!(arrowElement = data.instance.popper.querySelector(arrowElement))) return data } else if (!data.instance.popper.contains(arrowElement)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), data; var placement = data.placement.split("-")[0], _data = data.offsets, popper = _data.popper, reference = _data.reference, isVertical = -1 !== ["left", "right"].indexOf(placement), len = isVertical ? "height" : "width", sideCapitalized = isVertical ? "Top" : "Left", side = sideCapitalized.toLowerCase(), altSide = isVertical ? "left" : "top", opSide = isVertical ? "bottom" : "right", arrowElementSize = getOuterSizes(arrowElement)[len]; reference[opSide] - arrowElementSize < popper[side] && (data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)), reference[side] + arrowElementSize > popper[opSide] && (data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]), data.offsets.popper = getClientRect(data.offsets.popper); var center = reference[side] + reference[len] / 2 - arrowElementSize / 2, css = getStyleComputedProperty(data.instance.popper), popperMarginSide = parseFloat(css["margin" + sideCapitalized], 10), popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"], 10), sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; return sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0), data.arrowElement = arrowElement, data.offsets.arrow = (defineProperty(_data = {}, side, Math.round(sideValue)), defineProperty(_data, altSide, ""), _data), data } function getOppositeVariation(variation) { return "end" === variation ? "start" : "start" === variation ? "end" : variation } var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], validPlacements = placements.slice(3); function clockwise(placement) { var counter = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], index = validPlacements.indexOf(placement), arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index)); return counter ? arr.reverse() : arr } var BEHAVIORS = { FLIP: "flip", CLOCKWISE: "clockwise", COUNTERCLOCKWISE: "counterclockwise" }; function flip(data, options) { if (isModifierEnabled(data.instance.modifiers, "inner")) return data; if (data.flipped && data.placement === data.originalPlacement) return data; var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed), placement = data.placement.split("-")[0], placementOpposite = getOppositePlacement(placement), variation = data.placement.split("-")[1] || "", flipOrder = []; switch (options.behavior) { case BEHAVIORS.FLIP: flipOrder = [placement, placementOpposite]; break; case BEHAVIORS.CLOCKWISE: flipOrder = clockwise(placement); break; case BEHAVIORS.COUNTERCLOCKWISE: flipOrder = clockwise(placement, !0); break; default: flipOrder = options.behavior }return flipOrder.forEach(function (step, index) { if (placement !== step || flipOrder.length === index + 1) return data; placement = data.placement.split("-")[0], placementOpposite = getOppositePlacement(placement); var popperOffsets = data.offsets.popper, refOffsets = data.offsets.reference, floor = Math.floor, overlapsRef = "left" === placement && floor(popperOffsets.right) > floor(refOffsets.left) || "right" === placement && floor(popperOffsets.left) < floor(refOffsets.right) || "top" === placement && floor(popperOffsets.bottom) > floor(refOffsets.top) || "bottom" === placement && floor(popperOffsets.top) < floor(refOffsets.bottom), overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left), overflowsRight = floor(popperOffsets.right) > floor(boundaries.right), overflowsTop = floor(popperOffsets.top) < floor(boundaries.top), overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom), overflowsBoundaries = "left" === placement && overflowsLeft || "right" === placement && overflowsRight || "top" === placement && overflowsTop || "bottom" === placement && overflowsBottom, isVertical = -1 !== ["top", "bottom"].indexOf(placement), flippedVariation = !!options.flipVariations && (isVertical && "start" === variation && overflowsLeft || isVertical && "end" === variation && overflowsRight || !isVertical && "start" === variation && overflowsTop || !isVertical && "end" === variation && overflowsBottom); (overlapsRef || overflowsBoundaries || flippedVariation) && (data.flipped = !0, (overlapsRef || overflowsBoundaries) && (placement = flipOrder[index + 1]), flippedVariation && (variation = getOppositeVariation(variation)), data.placement = placement + (variation ? "-" + variation : ""), data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement)), data = runModifiers(data.instance.modifiers, data, "flip")) }), data } function keepTogether(data) { var _data = data.offsets, popper = _data.popper, reference = _data.reference, placement = data.placement.split("-")[0], floor = Math.floor, isVertical = -1 !== ["top", "bottom"].indexOf(placement), side = isVertical ? "right" : "bottom", opSide = isVertical ? "left" : "top", measurement = isVertical ? "width" : "height"; return popper[side] < floor(reference[opSide]) && (data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]), popper[opSide] > floor(reference[side]) && (data.offsets.popper[opSide] = floor(reference[side])), data } function toValue(str, measurement, popperOffsets, referenceOffsets) { var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/), value = +split[1], unit = split[2]; if (!value) return str; if (0 === unit.indexOf("%")) { var element = void 0, rect; switch (unit) { case "%p": element = popperOffsets; break; case "%": case "%r": default: element = referenceOffsets }return getClientRect(element)[measurement] / 100 * value } if ("vh" === unit || "vw" === unit) { var size = void 0; return (size = "vh" === unit ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * value } return value } function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) { var offsets = [0, 0], useHeight = -1 !== ["right", "left"].indexOf(basePlacement), fragments = offset.split(/(\+|\-)/).map(function (frag) { return frag.trim() }), divider = fragments.indexOf(find(fragments, function (frag) { return -1 !== frag.search(/,|\s/) })); fragments[divider] && -1 === fragments[divider].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead."); var splitRegex = /\s*,\s*|\s+/, ops = -1 !== divider ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; return (ops = ops.map(function (op, index) { var measurement = (1 === index ? !useHeight : useHeight) ? "height" : "width", mergeWithPrevious = !1; return op.reduce(function (a, b) { return "" === a[a.length - 1] && -1 !== ["+", "-"].indexOf(b) ? (a[a.length - 1] = b, mergeWithPrevious = !0, a) : mergeWithPrevious ? (a[a.length - 1] += b, mergeWithPrevious = !1, a) : a.concat(b) }, []).map(function (str) { return toValue(str, measurement, popperOffsets, referenceOffsets) }) })).forEach(function (op, index) { op.forEach(function (frag, index2) { isNumeric(frag) && (offsets[index] += frag * ("-" === op[index2 - 1] ? -1 : 1)) }) }), offsets } function offset(data, _ref) { var offset = _ref.offset, placement = data.placement, _data = data.offsets, popper = _data.popper, reference = _data.reference, basePlacement = placement.split("-")[0], offsets = void 0; return offsets = isNumeric(+offset) ? [+offset, 0] : parseOffset(offset, popper, reference, basePlacement), "left" === basePlacement ? (popper.top += offsets[0], popper.left -= offsets[1]) : "right" === basePlacement ? (popper.top += offsets[0], popper.left += offsets[1]) : "top" === basePlacement ? (popper.left += offsets[0], popper.top -= offsets[1]) : "bottom" === basePlacement && (popper.left += offsets[0], popper.top += offsets[1]), data.popper = popper, data } function preventOverflow(data, options) { var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); data.instance.reference === boundariesElement && (boundariesElement = getOffsetParent(boundariesElement)); var transformProp = getSupportedPropertyName("transform"), popperStyles = data.instance.popper.style, top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp]; popperStyles.top = "", popperStyles.left = "", popperStyles[transformProp] = ""; var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); popperStyles.top = top, popperStyles.left = left, popperStyles[transformProp] = transform, options.boundaries = boundaries; var order = options.priority, popper = data.offsets.popper, check = { primary: function primary(placement) { var value = popper[placement]; return popper[placement] < boundaries[placement] && !options.escapeWithReference && (value = Math.max(popper[placement], boundaries[placement])), defineProperty({}, placement, value) }, secondary: function secondary(placement) { var mainSide = "right" === placement ? "left" : "top", value = popper[mainSide]; return popper[placement] > boundaries[placement] && !options.escapeWithReference && (value = Math.min(popper[mainSide], boundaries[placement] - ("right" === placement ? popper.width : popper.height))), defineProperty({}, mainSide, value) } }; return order.forEach(function (placement) { var side = -1 !== ["left", "top"].indexOf(placement) ? "primary" : "secondary"; popper = _extends({}, popper, check[side](placement)) }), data.offsets.popper = popper, data } function shift(data) { var placement = data.placement, basePlacement = placement.split("-")[0], shiftvariation = placement.split("-")[1]; if (shiftvariation) { var _data = data.offsets, reference = _data.reference, popper = _data.popper, isVertical = -1 !== ["bottom", "top"].indexOf(basePlacement), side = isVertical ? "left" : "top", measurement = isVertical ? "width" : "height", shiftOffsets = { start: defineProperty({}, side, reference[side]), end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement]) }; data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]) } return data } function hide(data) { if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) return data; var refRect = data.offsets.reference, bound = find(data.instance.modifiers, function (modifier) { return "preventOverflow" === modifier.name }).boundaries; if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) { if (!0 === data.hide) return data; data.hide = !0, data.attributes["x-out-of-boundaries"] = "" } else { if (!1 === data.hide) return data; data.hide = !1, data.attributes["x-out-of-boundaries"] = !1 } return data } function inner(data) { var placement = data.placement, basePlacement = placement.split("-")[0], _data = data.offsets, popper = _data.popper, reference = _data.reference, isHoriz = -1 !== ["left", "right"].indexOf(basePlacement), subtractLength = -1 === ["top", "left"].indexOf(basePlacement); return popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0), data.placement = getOppositePlacement(placement), data.offsets.popper = getClientRect(popper), data } var modifiers, Defaults = { placement: "bottom", positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate: function onCreate() { }, onUpdate: function onUpdate() { }, modifiers: { shift: { order: 100, enabled: !0, fn: shift }, offset: { order: 200, enabled: !0, fn: offset, offset: 0 }, preventOverflow: { order: 300, enabled: !0, fn: preventOverflow, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent" }, keepTogether: { order: 400, enabled: !0, fn: keepTogether }, arrow: { order: 500, enabled: !0, fn: arrow, element: "[x-arrow]" }, flip: { order: 600, enabled: !0, fn: flip, behavior: "flip", padding: 5, boundariesElement: "viewport" }, inner: { order: 700, enabled: !1, fn: inner }, hide: { order: 800, enabled: !0, fn: hide }, computeStyle: { order: 850, enabled: !0, fn: computeStyle, gpuAcceleration: !0, x: "bottom", y: "right" }, applyStyle: { order: 900, enabled: !0, fn: applyStyle, onLoad: applyStyleOnLoad, gpuAcceleration: void 0 } } }, Popper = function () { function Popper(reference, popper) { var _this = this, options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; classCallCheck(this, Popper), this.scheduleUpdate = function () { return requestAnimationFrame(_this.update) }, this.update = debounce(this.update.bind(this)), this.options = _extends({}, Popper.Defaults, options), this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = reference && reference.jquery ? reference[0] : reference, this.popper = popper && popper.jquery ? popper[0] : popper, this.options.modifiers = {}, Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) { _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {}) }), this.modifiers = Object.keys(this.options.modifiers).map(function (name) { return _extends({ name: name }, _this.options.modifiers[name]) }).sort(function (a, b) { return a.order - b.order }), this.modifiers.forEach(function (modifierOptions) { modifierOptions.enabled && isFunction(modifierOptions.onLoad) && modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state) }), this.update(); var eventsEnabled = this.options.eventsEnabled; eventsEnabled && this.enableEventListeners(), this.state.eventsEnabled = eventsEnabled } return createClass(Popper, [{ key: "update", value: function update$() { return update.call(this) } }, { key: "destroy", value: function destroy$() { return destroy.call(this) } }, { key: "enableEventListeners", value: function enableEventListeners$() { return enableEventListeners.call(this) } }, { key: "disableEventListeners", value: function disableEventListeners$() { return disableEventListeners.call(this) } }]), Popper }(); Popper.Utils = ("undefined" != typeof window ? window : global).PopperUtils, Popper.placements = placements, Popper.Defaults = Defaults; var css = '.tippy-iOS{cursor:pointer!important}.tippy-notransition{transition:none}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px) rotateX(0);transform:perspective(700px) translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(60deg);transform:perspective(700px) translateY(0) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px) rotateX(0);transform:perspective(700px) translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(-60deg);transform:perspective(700px) translateY(0) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px) rotateY(0);transform:perspective(700px) translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(-60deg);transform:perspective(700px) translateX(0) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px) rotateY(0);transform:perspective(700px) translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(60deg);transform:perspective(700px) translateX(0) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=visible]{opacity:1}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}'; function _extends() { return (_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]) } return target }).apply(this, arguments) } var version = "4.2.0", isBrowser = "undefined" != typeof window && "undefined" != typeof document, ua = isBrowser ? navigator.userAgent : "", isIE = /MSIE |Trident\//.test(ua), isUCBrowser = /UCBrowser\//.test(ua), isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream, defaultProps = { a11y: !0, allowHTML: !0, animateFill: !0, animation: "shift-away", appendTo: function appendTo() { return document.body }, aria: "describedby", arrow: !1, arrowType: "sharp", boundary: "scrollParent", content: "", delay: 0, distance: 10, duration: [325, 275], flip: !0, flipBehavior: "flip", flipOnUpdate: !1, followCursor: !1, hideOnClick: !0, ignoreAttributes: !1, inertia: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, lazy: !0, maxWidth: 350, multiple: !1, offset: 0, onHidden: function onHidden() { }, onHide: function onHide() { }, onMount: function onMount() { }, onShow: function onShow() { }, onShown: function onShown() { }, placement: "top", popperOptions: {}, role: "tooltip", showOnInit: !1, size: "regular", sticky: !1, target: "", theme: "dark", touch: !0, touchHold: !1, trigger: "mouseenter focus", updateDuration: 0, wait: null, zIndex: 9999 }, POPPER_INSTANCE_DEPENDENCIES = ["arrow", "arrowType", "boundary", "distance", "flip", "flipBehavior", "flipOnUpdate", "offset", "placement", "popperOptions"], Selectors = { POPPER: ".tippy-popper", TOOLTIP: ".tippy-tooltip", CONTENT: ".tippy-content", BACKDROP: ".tippy-backdrop", ARROW: ".tippy-arrow", ROUND_ARROW: ".tippy-roundarrow" }, elementProto = isBrowser ? Element.prototype : {}, matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector; function arrayFrom(value) { return [].slice.call(value) } function closest(element, parentSelector) { return (elementProto.closest || function (selector) { for (var el = this; el;) { if (matches.call(el, selector)) return el; el = el.parentElement } }).call(element, parentSelector) } function closestCallback(element, callback) { for (; element;) { if (callback(element)) return element; element = element.parentElement } } var PASSIVE = { passive: !0 }, PADDING = 4, keys = Object.keys(defaultProps); function getDataAttributeOptions(reference) { return keys.reduce(function (acc, key) { var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || "").trim(); if (!valueAsString) return acc; if ("content" === key) acc[key] = valueAsString; else try { acc[key] = JSON.parse(valueAsString) } catch (e) { acc[key] = valueAsString } return acc }, {}) } function polyfillElementPrototypeProperties(virtualReference) { var polyfills = { isVirtual: !0, attributes: virtualReference.attributes || {}, setAttribute: function setAttribute(key, value) { virtualReference.attributes[key] = value }, getAttribute: function getAttribute(key) { return virtualReference.attributes[key] }, removeAttribute: function removeAttribute(key) { delete virtualReference.attributes[key] }, hasAttribute: function hasAttribute(key) { return key in virtualReference.attributes }, addEventListener: function addEventListener() { }, removeEventListener: function removeEventListener() { }, classList: { classNames: {}, add: function add(key) { virtualReference.classList.classNames[key] = !0 }, remove: function remove(key) { delete virtualReference.classList.classNames[key] }, contains: function contains(key) { return key in virtualReference.classList.classNames } } }; for (var key in polyfills) virtualReference[key] = polyfills[key] } function isBareVirtualElement(value) { return "[object Object]" === {}.toString.call(value) && !value.addEventListener } function hasOwnProperty(obj, key) { return {}.hasOwnProperty.call(obj, key) } function getArrayOfElements(value) { if (isSingular(value)) return [value]; if (value instanceof NodeList) return arrayFrom(value); if (Array.isArray(value)) return value; try { return arrayFrom(document.querySelectorAll(value)) } catch (e) { return [] } } function getValue(value, index, defaultValue) { if (Array.isArray(value)) { var v = value[index]; return null == v ? defaultValue : v } return value } function debounce(fn, ms) { var timeoutId; return function () { var _this = this, _arguments = arguments; clearTimeout(timeoutId), timeoutId = setTimeout(function () { return fn.apply(_this, _arguments) }, ms) } } function getModifier(obj, key) { return obj && obj.modifiers && obj.modifiers[key] } function includes(a, b) { return a.indexOf(b) > -1 } function isSingular(value) { return !(!value || !hasOwnProperty(value, "isVirtual")) || value instanceof Element } function innerHTML() { return "innerHTML" } function evaluateValue(value, args) { return "function" == typeof value ? value.apply(null, args) : value } function setFlipModifierEnabled(modifiers, value) { modifiers.filter(function (m) { return "flip" === m.name })[0].enabled = value } function canReceiveFocus(element) { return !(element instanceof Element) || matches.call(element, "a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]") && !element.hasAttribute("disabled") } function div() { return document.createElement("div") } function evaluateProps(reference, props) { var out = _extends({}, props, { content: evaluateValue(props.content, [reference]) }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference)); return (out.arrow || isUCBrowser) && (out.animateFill = !1), out } function validateOptions(options, defaultProps) { Object.keys(options).forEach(function (option) { if (!hasOwnProperty(defaultProps, option)) throw new Error("[tippy]: `".concat(option, "` is not a valid option")) }) } function setInnerHTML(element, html) { element.innerHTML = html instanceof Element ? html.innerHTML : html } function setContent(contentEl, props) { if (props.content instanceof Element) setInnerHTML(contentEl, ""), contentEl.appendChild(props.content); else if ("function" != typeof props.content) { var key; contentEl[props.allowHTML ? "innerHTML" : "textContent"] = props.content } } function getChildren(popper) { return { tooltip: popper.querySelector(Selectors.TOOLTIP), backdrop: popper.querySelector(Selectors.BACKDROP), content: popper.querySelector(Selectors.CONTENT), arrow: popper.querySelector(Selectors.ARROW) || popper.querySelector(Selectors.ROUND_ARROW) } } function addInertia(tooltip) { tooltip.setAttribute("data-inertia", "") } function removeInertia(tooltip) { tooltip.removeAttribute("data-inertia") } function createArrowElement(arrowType) { var arrow = div(); return "round" === arrowType ? (arrow.className = "tippy-roundarrow", setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>')) : arrow.className = "tippy-arrow", arrow } function createBackdropElement() { var backdrop = div(); return backdrop.className = "tippy-backdrop", backdrop.setAttribute("data-state", "hidden"), backdrop } function addInteractive(popper, tooltip) { popper.setAttribute("tabindex", "-1"), tooltip.setAttribute("data-interactive", "") } function removeInteractive(popper, tooltip) { popper.removeAttribute("tabindex"), tooltip.removeAttribute("data-interactive") } function applyTransitionDuration(els, value) { els.forEach(function (el) { el && (el.style.transitionDuration = "".concat(value, "ms")) }) } function toggleTransitionEndListener(tooltip, action, listener) { var eventName = isUCBrowser && void 0 !== document.body.style.webkitTransition ? "webkitTransitionEnd" : "transitionend"; tooltip[action + "EventListener"](eventName, listener) } function getPopperPlacement(popper) { var fullPlacement = popper.getAttribute("x-placement"); return fullPlacement ? fullPlacement.split("-")[0] : "" } function setVisibilityState(els, state) { els.forEach(function (el) { el && el.setAttribute("data-state", state) }) } function reflow(popper) { popper.offsetHeight } function toggleTheme(tooltip, action, theme) { theme.split(" ").forEach(function (themeName) { tooltip.classList[action](themeName + "-theme") }) } function createPopperElement(id, props) { var popper = div(); popper.className = "tippy-popper", popper.id = "tippy-".concat(id), popper.style.zIndex = "" + props.zIndex, props.role && popper.setAttribute("role", props.role); var tooltip = div(); tooltip.className = "tippy-tooltip", tooltip.style.maxWidth = props.maxWidth + ("number" == typeof props.maxWidth ? "px" : ""), tooltip.setAttribute("data-size", props.size), tooltip.setAttribute("data-animation", props.animation), tooltip.setAttribute("data-state", "hidden"), toggleTheme(tooltip, "add", props.theme); var content = div(); return content.className = "tippy-content", content.setAttribute("data-state", "hidden"), props.interactive && addInteractive(popper, tooltip), props.arrow && tooltip.appendChild(createArrowElement(props.arrowType)), props.animateFill && (tooltip.appendChild(createBackdropElement()), tooltip.setAttribute("data-animatefill", "")), props.inertia && addInertia(tooltip), setContent(content, props), tooltip.appendChild(content), popper.appendChild(tooltip), popper } function updatePopperElement(popper, prevProps, nextProps) { var _getChildren = getChildren(popper), tooltip = _getChildren.tooltip, content = _getChildren.content, backdrop = _getChildren.backdrop, arrow = _getChildren.arrow; popper.style.zIndex = "" + nextProps.zIndex, tooltip.setAttribute("data-size", nextProps.size), tooltip.setAttribute("data-animation", nextProps.animation), tooltip.style.maxWidth = nextProps.maxWidth + ("number" == typeof nextProps.maxWidth ? "px" : ""), nextProps.role ? popper.setAttribute("role", nextProps.role) : popper.removeAttribute("role"), prevProps.content !== nextProps.content && setContent(content, nextProps), !prevProps.animateFill && nextProps.animateFill ? (tooltip.appendChild(createBackdropElement()), tooltip.setAttribute("data-animatefill", "")) : prevProps.animateFill && !nextProps.animateFill && (tooltip.removeChild(backdrop), tooltip.removeAttribute("data-animatefill")), !prevProps.arrow && nextProps.arrow ? tooltip.appendChild(createArrowElement(nextProps.arrowType)) : prevProps.arrow && !nextProps.arrow && tooltip.removeChild(arrow), prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType && tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow), !prevProps.interactive && nextProps.interactive ? addInteractive(popper, tooltip) : prevProps.interactive && !nextProps.interactive && removeInteractive(popper, tooltip), !prevProps.inertia && nextProps.inertia ? addInertia(tooltip) : prevProps.inertia && !nextProps.inertia && removeInertia(tooltip), prevProps.theme !== nextProps.theme && (toggleTheme(tooltip, "remove", prevProps.theme), toggleTheme(tooltip, "add", nextProps.theme)) } function afterPopperPositionUpdates(popperInstance, callback) { var popper = popperInstance.popper, options = popperInstance.options, onCreate = options.onCreate, onUpdate = options.onUpdate; options.onCreate = options.onUpdate = function (data) { reflow(popper), callback(), onUpdate && onUpdate(data), options.onCreate = onCreate, options.onUpdate = onUpdate } } function hideAll() { var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, checkHideOnClick = _ref.checkHideOnClick, exclude = _ref.exclude, duration = _ref.duration; arrayFrom(document.querySelectorAll(Selectors.POPPER)).forEach(function (popper) { var instance = popper._tippy; !instance || checkHideOnClick && !0 !== instance.props.hideOnClick || exclude && popper === exclude.popper || instance.hide(duration) }) } function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) { if (!popperPlacement) return !0; var x = event.clientX, y = event.clientY, interactiveBorder = props.interactiveBorder, distance = props.distance, exceedsTop = popperRect.top - y > ("top" === popperPlacement ? interactiveBorder + distance : interactiveBorder), exceedsBottom = y - popperRect.bottom > ("bottom" === popperPlacement ? interactiveBorder + distance : interactiveBorder), exceedsLeft = popperRect.left - x > ("left" === popperPlacement ? interactiveBorder + distance : interactiveBorder), exceedsRight = x - popperRect.right > ("right" === popperPlacement ? interactiveBorder + distance : interactiveBorder); return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight } function getOffsetDistanceInPx(distance) { return -(distance - 10) + "px" } var isUsingTouch = !1; function onDocumentTouch() { isUsingTouch || (isUsingTouch = !0, isIOS && document.body.classList.add("tippy-iOS"), window.performance && document.addEventListener("mousemove", onDocumentMouseMove)) } var lastMouseMoveTime = 0; function onDocumentMouseMove() { var now = performance.now(); now - lastMouseMoveTime < 20 && (isUsingTouch = !1, document.removeEventListener("mousemove", onDocumentMouseMove), isIOS || document.body.classList.remove("tippy-iOS")), lastMouseMoveTime = now } function onDocumentClick(event) { if (!(event.target instanceof Element)) return hideAll(); var popper = closest(event.target, Selectors.POPPER); if (!(popper && popper._tippy && popper._tippy.props.interactive)) { var reference = closestCallback(event.target, function (el) { return el._tippy && el._tippy.reference === el }); if (reference) { var instance = reference._tippy; if (instance) { var isClickTrigger = includes(instance.props.trigger || "", "click"); if (isUsingTouch || isClickTrigger) return hideAll({ exclude: instance, checkHideOnClick: !0 }); if (!0 !== instance.props.hideOnClick || isClickTrigger) return; instance.clearDelayTimeouts() } } hideAll({ checkHideOnClick: !0 }) } } function onWindowBlur() { var _document, activeElement = document.activeElement; activeElement && activeElement.blur && activeElement._tippy && activeElement.blur() } function bindGlobalEventListeners() { document.addEventListener("click", onDocumentClick, !0), document.addEventListener("touchstart", onDocumentTouch, PASSIVE), window.addEventListener("blur", onWindowBlur) } var idCounter = 1; function createTippy(reference, collectionProps) { var props = evaluateProps(reference, collectionProps), lastTriggerEventType, lastMouseMoveEvent, showTimeoutId, hideTimeoutId, animationFrameId; if (!props.multiple && reference._tippy) return null; var isScheduledToShow = !1, transitionEndListener, listeners = [], debouncedOnMouseMove = props.interactiveDebounce > 0 ? debounce(onMouseMove, props.interactiveDebounce) : onMouseMove, parentNode, id = idCounter++, popper = createPopperElement(id, props), popperChildren, state, popperInstance = null, instance = { id: id, reference: reference, popper: popper, popperChildren: getChildren(popper), popperInstance: null, props: props, state: { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, clearDelayTimeouts: clearDelayTimeouts, set: set, setContent: setContent$, show: show, hide: hide, enable: enable, disable: disable, destroy: destroy }; return addTriggersToReference(), props.lazy || (createPopperInstance(), instance.popperInstance.disableEventListeners()), props.showOnInit && scheduleShow(), !props.a11y || props.target || canReceiveFocus(reference) || reference.setAttribute("tabindex", "0"), popper.addEventListener("mouseenter", function (event) { instance.props.interactive && instance.state.isVisible && "mouseenter" === lastTriggerEventType && scheduleShow(event) }), popper.addEventListener("mouseleave", function () { instance.props.interactive && "mouseenter" === lastTriggerEventType && document.addEventListener("mousemove", debouncedOnMouseMove) }), reference._tippy = instance, popper._tippy = instance, instance; function positionVirtualReferenceNearCursor(event) { var _lastMouseMoveEvent = lastMouseMoveEvent = event, clientX = _lastMouseMoveEvent.clientX, clientY = _lastMouseMoveEvent.clientY; if (instance.popperInstance) { var placement = getPopperPlacement(instance.popper), padding = instance.props.arrow ? PADDING + ("round" === instance.props.arrowType ? 18 : 16) : PADDING, isVerticalPlacement = includes(["top", "bottom"], placement), isHorizontalPlacement = includes(["left", "right"], placement), x = isVerticalPlacement ? Math.max(padding, clientX) : clientX, y = isHorizontalPlacement ? Math.max(padding, clientY) : clientY; isVerticalPlacement && x > padding && (x = Math.min(clientX, window.innerWidth - padding)), isHorizontalPlacement && y > padding && (y = Math.min(clientY, window.innerHeight - padding)); var rect = instance.reference.getBoundingClientRect(), followCursor = instance.props.followCursor, isHorizontal = "horizontal" === followCursor, isVertical = "vertical" === followCursor; instance.popperInstance.reference = _extends({}, instance.popperInstance.reference, { getBoundingClientRect: function getBoundingClientRect() { return { width: 0, height: 0, top: isHorizontal ? rect.top : y, bottom: isHorizontal ? rect.bottom : y, left: isVertical ? rect.left : x, right: isVertical ? rect.right : x } }, clientWidth: 0, clientHeight: 0 }), instance.popperInstance.scheduleUpdate(), "initial" === followCursor && instance.state.isVisible && removeFollowCursorListener() } } function createDelegateChildTippy(event) { if (event) { var targetEl = closest(event.target, instance.props.target); targetEl && !targetEl._tippy && (createTippy(targetEl, _extends({}, instance.props, { content: evaluateValue(collectionProps.content, [targetEl]), appendTo: collectionProps.appendTo, target: "", showOnInit: !0 })), scheduleShow(event)) } } function scheduleShow(event) { if (clearDelayTimeouts(), !instance.state.isVisible) { if (instance.props.target) return createDelegateChildTippy(event); if (isScheduledToShow = !0, instance.props.wait) return instance.props.wait(instance, event); hasFollowCursorBehavior() && !instance.state.isMounted && document.addEventListener("mousemove", positionVirtualReferenceNearCursor); var delay = getValue(instance.props.delay, 0, defaultProps.delay); delay ? showTimeoutId = setTimeout(function () { show() }, delay) : show() } } function scheduleHide() { if (clearDelayTimeouts(), !instance.state.isVisible) return removeFollowCursorListener(); isScheduledToShow = !1; var delay = getValue(instance.props.delay, 1, defaultProps.delay); delay ? hideTimeoutId = setTimeout(function () { instance.state.isVisible && hide() }, delay) : animationFrameId = requestAnimationFrame(function () { hide() }) } function removeFollowCursorListener() { document.removeEventListener("mousemove", positionVirtualReferenceNearCursor) } function cleanupOldMouseListeners() { document.body.removeEventListener("mouseleave", scheduleHide), document.removeEventListener("mousemove", debouncedOnMouseMove) } function onTrigger(event) { instance.state.isEnabled && !isEventListenerStopped(event) && (instance.state.isVisible || (lastTriggerEventType = event.type, event instanceof MouseEvent && (lastMouseMoveEvent = event)), "click" === event.type && !1 !== instance.props.hideOnClick && instance.state.isVisible ? scheduleHide() : scheduleShow(event)) } function onMouseMove(event) { var referenceTheCursorIsOver = closestCallback(event.target, function (el) { return el._tippy }), isCursorOverPopper = closest(event.target, Selectors.POPPER) === instance.popper, isCursorOverReference = referenceTheCursorIsOver === instance.reference; isCursorOverPopper || isCursorOverReference || isCursorOutsideInteractiveBorder(getPopperPlacement(instance.popper), instance.popper.getBoundingClientRect(), event, instance.props) && (cleanupOldMouseListeners(), scheduleHide()) } function onMouseLeave(event) { if (!isEventListenerStopped(event)) return instance.props.interactive ? (document.body.addEventListener("mouseleave", scheduleHide), void document.addEventListener("mousemove", debouncedOnMouseMove)) : void scheduleHide() } function onBlur(event) { event.target === instance.reference && (instance.props.interactive && event.relatedTarget && instance.popper.contains(event.relatedTarget) || scheduleHide()) } function onDelegateShow(event) { closest(event.target, instance.props.target) && scheduleShow(event) } function onDelegateHide(event) { closest(event.target, instance.props.target) && scheduleHide() } function isEventListenerStopped(event) { var supportsTouch = "ontouchstart" in window, isTouchEvent = includes(event.type, "touch"), touchHold = instance.props.touchHold; return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent } function createPopperInstance() { var popperOptions = instance.props.popperOptions, _instance = instance.popperChildren, tooltip = _instance.tooltip, arrow = _instance.arrow, preventOverflowModifier = getModifier(popperOptions, "preventOverflow"); function applyMutations(data) { instance.props.flip && !instance.props.flipOnUpdate && (data.flipped && (instance.popperInstance.options.placement = data.placement), setFlipModifierEnabled(instance.popperInstance.modifiers, !1)), tooltip.setAttribute("x-placement", data.placement); var basePlacement = getPopperPlacement(instance.popper), styles = tooltip.style; styles.top = styles.bottom = styles.left = styles.right = "", styles[basePlacement] = getOffsetDistanceInPx(instance.props.distance); var padding = preventOverflowModifier && void 0 !== preventOverflowModifier.padding ? preventOverflowModifier.padding : PADDING, isPaddingNumber = "number" == typeof padding, computedPadding = _extends({ top: isPaddingNumber ? padding : padding.top, bottom: isPaddingNumber ? padding : padding.bottom, left: isPaddingNumber ? padding : padding.left, right: isPaddingNumber ? padding : padding.right }, !isPaddingNumber && padding); computedPadding[basePlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basePlacement] || 0) + instance.props.distance, instance.popperInstance.modifiers.filter(function (m) { return "preventOverflow" === m.name })[0].padding = computedPadding } var config = _extends({ placement: instance.props.placement }, popperOptions, { modifiers: _extends({}, popperOptions ? popperOptions.modifiers : {}, { preventOverflow: _extends({ boundariesElement: instance.props.boundary, padding: PADDING }, preventOverflowModifier), arrow: _extends({ element: arrow, enabled: !!arrow }, getModifier(popperOptions, "arrow")), flip: _extends({ enabled: instance.props.flip, padding: instance.props.distance + PADDING, behavior: instance.props.flipBehavior }, getModifier(popperOptions, "flip")), offset: _extends({ offset: instance.props.offset }, getModifier(popperOptions, "offset")) }), onCreate: function onCreate(data) { applyMutations(data), popperOptions && popperOptions.onCreate && popperOptions.onCreate(data) }, onUpdate: function onUpdate(data) { applyMutations(data), popperOptions && popperOptions.onUpdate && popperOptions.onUpdate(data) } }); instance.popperInstance = new Popper(instance.reference, instance.popper, config) } function mount(callback) { var shouldEnableListeners = !(hasFollowCursorBehavior() || "initial" === instance.props.followCursor && isUsingTouch); instance.popperInstance ? (hasFollowCursorBehavior() || (instance.popperInstance.scheduleUpdate(), shouldEnableListeners && instance.popperInstance.enableEventListeners()), setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip)) : (createPopperInstance(), shouldEnableListeners || instance.popperInstance.disableEventListeners()), instance.popperInstance.reference = instance.reference; var arrow = instance.popperChildren.arrow; hasFollowCursorBehavior() ? (arrow && (arrow.style.margin = "0"), lastMouseMoveEvent && positionVirtualReferenceNearCursor(lastMouseMoveEvent)) : arrow && (arrow.style.margin = ""), isUsingTouch && lastMouseMoveEvent && "initial" === instance.props.followCursor && (positionVirtualReferenceNearCursor(lastMouseMoveEvent), arrow && (arrow.style.margin = "0")), afterPopperPositionUpdates(instance.popperInstance, callback); var appendTo = instance.props.appendTo; (parentNode = "parent" === appendTo ? instance.reference.parentNode : evaluateValue(appendTo, [instance.reference])).contains(instance.popper) || (parentNode.appendChild(instance.popper), instance.props.onMount(instance), instance.state.isMounted = !0) } function hasFollowCursorBehavior() { return instance.props.followCursor && !isUsingTouch && "focus" !== lastTriggerEventType } function makeSticky() { function updatePosition() { instance.popperInstance && instance.popperInstance.scheduleUpdate(), instance.state.isMounted ? requestAnimationFrame(updatePosition) : applyTransitionDuration([instance.popper], 0) } applyTransitionDuration([instance.popper], isIE ? 0 : instance.props.updateDuration), updatePosition() } function onTransitionedOut(duration, callback) { onTransitionEnd(duration, function () { !instance.state.isVisible && parentNode && parentNode.contains(instance.popper) && callback() }) } function onTransitionedIn(duration, callback) { onTransitionEnd(duration, callback) } function onTransitionEnd(duration, callback) { var tooltip = instance.popperChildren.tooltip; function listener(event) { event.target === tooltip && (toggleTransitionEndListener(tooltip, "remove", listener), callback()) } if (0 === duration) return callback(); toggleTransitionEndListener(tooltip, "remove", transitionEndListener), toggleTransitionEndListener(tooltip, "add", listener), transitionEndListener = listener } function on(eventType, handler) { var options = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; instance.reference.addEventListener(eventType, handler, options), listeners.push({ eventType: eventType, handler: handler, options: options }) } function addTriggersToReference() { instance.props.touchHold && !instance.props.target && (on("touchstart", onTrigger, PASSIVE), on("touchend", onMouseLeave, PASSIVE)), instance.props.trigger.trim().split(" ").forEach(function (eventType) { if ("manual" !== eventType) if (instance.props.target) switch (eventType) { case "mouseenter": on("mouseover", onDelegateShow), on("mouseout", onDelegateHide); break; case "focus": on("focusin", onDelegateShow), on("focusout", onDelegateHide); break; case "click": on(eventType, onDelegateShow) } else switch (on(eventType, onTrigger), eventType) { case "mouseenter": on("mouseleave", onMouseLeave); break; case "focus": on(isIE ? "focusout" : "blur", onBlur) } }) } function removeTriggersFromReference() { listeners.forEach(function (_ref) { var eventType = _ref.eventType, handler = _ref.handler, options = _ref.options; instance.reference.removeEventListener(eventType, handler, options) }), listeners = [] } function getInnerElements() { return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content] } function enable() { instance.state.isEnabled = !0 } function disable() { instance.state.isEnabled = !1 } function clearDelayTimeouts() { clearTimeout(showTimeoutId), clearTimeout(hideTimeoutId), cancelAnimationFrame(animationFrameId) } function set(options) { validateOptions(options = options || {}, defaultProps); var prevProps = instance.props, nextProps = evaluateProps(instance.reference, _extends({}, instance.props, options, { ignoreAttributes: !0 })); nextProps.ignoreAttributes = hasOwnProperty(options, "ignoreAttributes") ? options.ignoreAttributes || !1 : prevProps.ignoreAttributes, instance.props = nextProps, (hasOwnProperty(options, "trigger") || hasOwnProperty(options, "touchHold")) && (removeTriggersFromReference(), addTriggersToReference()), hasOwnProperty(options, "interactiveDebounce") && (cleanupOldMouseListeners(), debouncedOnMouseMove = debounce(onMouseMove, options.interactiveDebounce || 0)), updatePopperElement(instance.popper, prevProps, nextProps), instance.popperChildren = getChildren(instance.popper), instance.popperInstance && (instance.popperInstance.update(), POPPER_INSTANCE_DEPENDENCIES.some(function (prop) { return hasOwnProperty(options, prop) }) && (instance.popperInstance.destroy(), createPopperInstance(), instance.state.isVisible || instance.popperInstance.disableEventListeners(), instance.props.followCursor && lastMouseMoveEvent && positionVirtualReferenceNearCursor(lastMouseMoveEvent))) } function setContent$(content) { set({ content: content }) } function show() { var duration = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]); if (!instance.state.isDestroyed && instance.state.isEnabled && (!isUsingTouch || instance.props.touch)) return hasOwnProperty(instance.reference, "isVirtual") || document.documentElement.contains(instance.reference) ? void (instance.reference.hasAttribute("disabled") || !1 !== instance.props.onShow(instance) && (instance.popper.style.visibility = "visible", instance.state.isVisible = !0, instance.props.interactive && instance.reference.classList.add("tippy-active"), applyTransitionDuration([instance.popper, instance.popperChildren.tooltip, instance.popperChildren.backdrop], 0), mount(function () { instance.state.isVisible && (hasFollowCursorBehavior() || instance.popperInstance.update(), applyTransitionDuration([instance.popper], props.updateDuration), applyTransitionDuration(getInnerElements(), duration), instance.popperChildren.backdrop && (instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + "ms"), instance.props.sticky && makeSticky(), setVisibilityState(getInnerElements(), "visible"), onTransitionedIn(duration, function () { instance.popperChildren.tooltip.classList.add("tippy-notransition"), instance.props.aria && instance.reference.setAttribute("aria-".concat(instance.props.aria), instance.popper.id), instance.props.onShown(instance), instance.state.isShown = !0 })) }))) : destroy() } function hide() { var duration = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]); !instance.state.isDestroyed && instance.state.isEnabled && !1 !== instance.props.onHide(instance) && (instance.popperChildren.tooltip.classList.remove("tippy-notransition"), instance.props.interactive && instance.reference.classList.remove("tippy-active"), instance.popper.style.visibility = "hidden", instance.state.isVisible = !1, instance.state.isShown = !1, applyTransitionDuration(getInnerElements(), duration), setVisibilityState(getInnerElements(), "hidden"), onTransitionedOut(duration, function () { isScheduledToShow || removeFollowCursorListener(), instance.props.aria && instance.reference.removeAttribute("aria-".concat(instance.props.aria)), instance.popperInstance.disableEventListeners(), instance.popperInstance.options.placement = instance.props.placement, parentNode.removeChild(instance.popper), instance.props.onHidden(instance), instance.state.isMounted = !1 })) } function destroy(destroyTargetInstances) { instance.state.isDestroyed || (instance.state.isMounted && hide(0), removeTriggersFromReference(), delete instance.reference._tippy, instance.props.target && destroyTargetInstances && arrayFrom(instance.reference.querySelectorAll(instance.props.target)).forEach(function (child) { child._tippy && child._tippy.destroy() }), instance.popperInstance && instance.popperInstance.destroy(), instance.state.isDestroyed = !0) } } function group(instances) { var _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref = _ref.delay, delay = void 0 === _ref ? instances[0].props.delay : _ref, _ref = _ref.duration, duration = void 0 === _ref ? 0 : _ref; if (!instances.some(function (instance) { return hasOwnProperty(instance, "_originalProps") })) { var isAnyTippyOpen = !1; instances.forEach(function (instance) { instance._originalProps = _extends({}, instance.props) }), updateInstances() } function setIsAnyTippyOpen(value) { isAnyTippyOpen = value, updateInstances() } function onShow(instance) { instance._originalProps.onShow(instance), instances.forEach(function (instance) { instance.set({ duration: duration }), instance.hide() }), setIsAnyTippyOpen(!0) } function onHide(instance) { instance._originalProps.onHide(instance), setIsAnyTippyOpen(!1) } function onShown(instance) { instance._originalProps.onShown(instance), instance.set({ duration: instance._originalProps.duration }) } function updateInstances() { instances.forEach(function (instance) { instance.set({ onShow: onShow, onShown: onShown, onHide: onHide, delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay, duration: isAnyTippyOpen ? duration : instance._originalProps.duration }) }) } } var globalEventListenersBound = !1; function tippy(targets, options) { validateOptions(options || {}, defaultProps), globalEventListenersBound || (bindGlobalEventListeners(), globalEventListenersBound = !0); var props = _extends({}, defaultProps, options); isBareVirtualElement(targets) && polyfillElementPrototypeProperties(targets); var instances = getArrayOfElements(targets).reduce(function (acc, reference) { var instance = reference && createTippy(reference, props); return instance && acc.push(instance), acc }, []); return isSingular(targets) ? instances[0] : instances } function autoInit() { arrayFrom(document.querySelectorAll("[data-tippy]")).forEach(function (el) { var content = el.getAttribute("data-tippy"); content && tippy(el, { content: content }) }) } function injectCSS(css) { if (isBrowser) { var style = document.createElement("style"); style.type = "text/css", style.textContent = css; var head = document.head, firstChild = head.firstChild; firstChild ? head.insertBefore(style, firstChild) : head.appendChild(style) } } tippy.version = "4.2.0", tippy.defaults = defaultProps, tippy.setDefaults = function (partialDefaults) { Object.keys(partialDefaults).forEach(function (key) { defaultProps[key] = partialDefaults[key] }) }, tippy.hideAll = hideAll, tippy.group = group, isBrowser && setTimeout(autoInit), injectCSS(css); const missingTippy = "Using the attachment feature of Shepherd requires the Tippy.js library", centeredStylePopperModifier = { computeStyle: { enabled: !0, fn: data => (data.styles = Object.assign({}, data.styles, { left: "50%", top: "50%", transform: "translate(-50%, -50%)" }), data) } }, defaultPopperOptions = { positionFixed: !0 }; function createFromHTML(html) { const el = document.createElement("div"); return el.innerHTML = html, el.children[0] } function _parseAttachToOpts(opts) { if (isObjectLike(opts)) return opts.hasOwnProperty("element") && opts.hasOwnProperty("on") ? opts : null; const positionRe = /^(.+) ((auto|top|left|right|bottom)(-start|-end)?)$/, matches = positionRe.exec(opts); return matches ? { element: matches[1], on: matches[2] } : null } function parseShorthand(obj, props) { if (null === obj || isUndefined(obj)) return obj; if (isObjectLike(obj)) return obj; const values = obj.split(" "); return zipObject(props, values) } function setupTooltip() { if (isUndefined(tippy)) throw new Error(missingTippy); this.tooltip && this.tooltip.destroy(); const attachToOpts = this.parseAttachTo(); this.tooltip = _makeTippyInstance.call(this, attachToOpts), this.target = attachToOpts.element || document.body, this.el.classList.add("shepherd-element") } function parseAttachTo() { const options = _parseAttachToOpts(this.options.attachTo) || {}, returnOpts = Object.assign({}, options); if (isString(options.element)) { try { returnOpts.element = document.querySelector(options.element) } catch (e) { } returnOpts.element || console.error(`The element for this Shepherd step was not found ${options.element}`) } return returnOpts } function _makeTippyInstance(attachToOptions) { if (!attachToOptions.element) return _makeCenteredTippy.call(this); const tippyOptions = _makeAttachedTippyOptions.call(this, attachToOptions); return tippy(attachToOptions.element, tippyOptions) } function _makeAttachedTippyOptions(attachToOptions) { const resultingTippyOptions = { content: this.el, flipOnUpdate: !0, placement: attachToOptions.on || "right" }; if (Object.assign(resultingTippyOptions, this.options.tippyOptions), this.options.title) { const existingTheme = resultingTippyOptions.theme; resultingTippyOptions.theme = existingTheme ? ` shepherd-has-title` : "shepherd-has-title" } return this.options.tippyOptions && this.options.tippyOptions.popperOptions && Object.assign(defaultPopperOptions, this.options.tippyOptions.popperOptions), resultingTippyOptions.popperOptions = defaultPopperOptions, resultingTippyOptions } function _makeCenteredTippy() { const tippyOptions = _objectSpread({ content: this.el, placement: "top" }, this.options.tippyOptions); tippyOptions.arrow = !1, tippyOptions.popperOptions = tippyOptions.popperOptions || {}; const finalPopperOptions = Object.assign({}, defaultPopperOptions, tippyOptions.popperOptions, { modifiers: Object.assign(centeredStylePopperModifier, tippyOptions.popperOptions.modifiers) }); return tippyOptions.popperOptions = finalPopperOptions, tippy(document.body, tippyOptions) } function _setupAdvanceOnHandler(selector) { return event => { if (this.isOpen()) { const targetIsEl = this.el && event.target === this.el, targetIsSelector = !isUndefined(selector) && event.target.matches(selector); (targetIsSelector || targetIsEl) && this.tour.next() } } } function bindAdvance() { const _parseShorthand = parseShorthand(this.options.advanceOn, ["selector", "event"]), event = _parseShorthand.event, selector = _parseShorthand.selector, handler = _setupAdvanceOnHandler.call(this, selector), el = document.querySelector(selector); !isUndefined(selector) && el ? el.addEventListener(event, handler) : document.body.addEventListener(event, handler, !0), this.on("destroy", () => document.body.removeEventListener(event, handler, !0)) } function bindButtonEvents(cfg, el) { cfg.events = cfg.events || {}, isUndefined(cfg.action) || (cfg.events.click = cfg.action), forOwn(cfg.events, (handler, event) => { if (isString(handler)) { const page = handler; handler = (() => this.tour.show(page)) } el.dataset.buttonEvent = !0, el.addEventListener(event, handler), this.on("destroy", () => { el.removeAttribute("data-button-event"), el.removeEventListener(event, handler) }) }) } function bindCancelLink(link) { link.addEventListener("click", e => { e.preventDefault(), this.cancel() }) } function bindMethods(methods) { methods.map(method => { this[method] = this[method].bind(this) }) } const uniqueId = function () { let id = 0; return function () { return ++id } }(); class Step extends Evented { constructor(tour, options) { return super(tour, options), this.tour = tour, bindMethods.call(this, ["_show", "cancel", "complete", "destroy", "hide", "isOpen", "scrollTo", "setupElements", "show"]), this.setOptions(options), this.bindAdvance = bindAdvance.bind(this), this.bindButtonEvents = bindButtonEvents.bind(this), this.bindCancelLink = bindCancelLink.bind(this), this.setupTooltip = setupTooltip.bind(this), this.parseAttachTo = parseAttachTo.bind(this), this } _addButtons(content) { if (!isEmpty(this.options.buttons)) { const footer = document.createElement("footer"), buttons = createFromHTML('<ul class="shepherd-buttons"></ul>'); footer.classList.add("shepherd-footer"), this.options.buttons.map(cfg => { const button = createFromHTML(`<li><a class="shepherd-button ${cfg.classes || ""}" tabindex="0">${cfg.text}</a>`); buttons.appendChild(button), this.bindButtonEvents(cfg, button.querySelector("a")) }), footer.appendChild(buttons), content.appendChild(footer) } } _addCancelLink(element, header) { if (this.options.showCancelLink) { const link = createFromHTML('<a href class="shepherd-cancel-link"></a>'); header.appendChild(link), element.classList.add("shepherd-has-cancel-link"), this.bindCancelLink(link) } } _addContent(content) { const text = createFromHTML('<div class="shepherd-text"></div>'); let paragraphs = this.options.text; isFunction(paragraphs) && (paragraphs = paragraphs.call(this, text)), paragraphs instanceof HTMLElement ? text.appendChild(paragraphs) : (isString(paragraphs) && (paragraphs = [paragraphs]), paragraphs.map(paragraph => { text.innerHTML += `<p></p>` })), content.appendChild(text) } _createTooltipContent() { const content = document.createElement("div"), classes = this.options.classes || "", element = createFromHTML(`<div class="" data-shepherd-step-id="${this.id}">`), header = document.createElement("header"); if (this.options.title) { const title = document.createElement("h3"); title.classList.add("shepherd-title"), title.innerHTML = `${this.options.title}`, header.appendChild(title), element.classList.add("shepherd-has-title") } return content.classList.add("shepherd-content"), header.classList.add("shepherd-header"), element.appendChild(content), content.appendChild(header), isUndefined(this.options.text) || this._addContent(content), this._addButtons(content), this._addCancelLink(element, header), element } getTour() { return this.tour } cancel() { this.tour.cancel(), this.trigger("cancel") } complete() { this.tour.complete(), this.trigger("complete") } destroy() { this.tooltip && (this.tooltip.destroy(), this.tooltip = null), isElement(this.el) && this.el.parentNode && (this.el.parentNode.removeChild(this.el), this.el = null), this.target && this._updateStepTargetOnHide(), this.trigger("destroy") } hide() { this.tour.modal.hide(), this.trigger("before-hide"), document.body.removeAttribute("data-shepherd-step"), this.target && this._updateStepTargetOnHide(), this.tooltip && this.tooltip.hide(), this.trigger("hide") } isOpen() { return Boolean(this.tooltip && this.tooltip.state && this.tooltip.state.isVisible) } setupElements() { isUndefined(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && this.bindAdvance(), this.setupTooltip() } scrollTo() { const _this = this.parseAttachTo(), element = _this.element; isFunction(this.options.scrollToHandler) ? this.options.scrollToHandler(element) : isElement(element) && element.scrollIntoView() } setOptions() { let options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.options = options; const when = this.options.when; this.destroy(), this.id = this.options.id || `step-${uniqueId()}`, forOwn(when, (handler, event) => { this.on(event, handler, this) }) } show() { if (isFunction(this.options.beforeShowPromise)) { const beforeShowPromise = this.options.beforeShowPromise(); if (!isUndefined(beforeShowPromise)) return beforeShowPromise.then(() => this._show()) } this._show() } _show() { this.tour.beforeShowStep(this), this.trigger("before-show"), this.el || this.setupElements(), this.target.classList.add("shepherd-enabled", "shepherd-target"), document.body.setAttribute("data-shepherd-step", this.id), this.options.scrollTo && setTimeout(() => { this.scrollTo() }), this.tooltip.show(), this.trigger("show") } _updateStepTargetOnHide() { this.options.highlightClass && this.target.classList.remove(this.options.highlightClass), this.target.classList.remove("shepherd-enabled", "shepherd-target") } } var numberTag = "[object Number]"; function isNumber(value) { return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag } const svgNS = "http://www.w3.org/2000/svg", elementIds = { modalOverlay: "shepherdModalOverlayContainer", modalOverlayMask: "shepherdModalMask", modalOverlayMaskRect: "shepherdModalMaskRect", modalOverlayMaskOpening: "shepherdModalMaskOpening" }, classNames = { isVisible: "shepherd-modal-is-visible", modalTarget: "shepherd-modal-target" }; function _createModalContainer() { const element = document.createElementNS(svgNS, "svg"); return element.setAttributeNS(null, "id", elementIds.modalOverlay), element } function _createMaskContainer() { const element = document.createElementNS(svgNS, "mask"); return _setAttributes(element, { height: "100%", id: elementIds.modalOverlayMask, width: "100%", x: "0", y: "0" }), element } function _createMaskRect() { const element = document.createElementNS(svgNS, "rect"); return _setAttributes(element, { fill: "#FFFFFF", height: "100%", id: elementIds.modalOverlayMaskRect, width: "100%", x: "0", y: "0" }), element } function _createMaskOpening() { const element = document.createElementNS(svgNS, "rect"); return _setAttributes(element, { fill: "#000000", id: elementIds.modalOverlayMaskOpening }), element } function _createMaskConsumer() { const element = document.createElementNS(svgNS, "rect"); return _setAttributes(element, { height: "100%", width: "100%", x: "0", y: "0" }), element.setAttribute("mask", `url(#${elementIds.modalOverlayMask})`), element } function createModalOverlay() { const containerElement = _createModalContainer(), defsElement = document.createElementNS(svgNS, "defs"), maskContainer = _createMaskContainer(), maskRect = _createMaskRect(), maskOpening = _createMaskOpening(), maskConsumer = _createMaskConsumer(); return maskContainer.appendChild(maskRect), maskContainer.appendChild(maskOpening), defsElement.appendChild(maskContainer), containerElement.appendChild(defsElement), containerElement.appendChild(maskConsumer), containerElement } function positionModalOpening(targetElement, openingElement) { if (targetElement.getBoundingClientRect && openingElement instanceof SVGElement) { const _targetElement = targetElement.getBoundingClientRect(), x = _targetElement.x, y = _targetElement.y, width = _targetElement.width, height = _targetElement.height, left = _targetElement.left, top = _targetElement.top; _setAttributes(openingElement, { x: x || left, y: y || top, width: width, height: height }) } } function closeModalOpening(openingElement) { openingElement && openingElement instanceof SVGElement && _setAttributes(openingElement, { height: "0", x: "0", y: "0", width: "0" }) } function getModalMaskOpening(modalElement) { return modalElement.querySelector(`#${elementIds.modalOverlayMaskOpening}`) } function preventModalBodyTouch(event) { event.preventDefault() } function preventModalOverlayTouch(event) { event.stopPropagation() } function toggleShepherdModalClass(currentElement) { const shepherdModal = document.querySelector(`${classNames.modalTarget}`); shepherdModal && shepherdModal.classList.remove(classNames.modalTarget), currentElement.classList.add(classNames.modalTarget) } function _setAttributes(el, attrs) { Object.keys(attrs).forEach(key => { el.setAttribute(key, attrs[key]) }) } function getElementFromObject(attachTo) { const op = attachTo.element; return op instanceof HTMLElement ? op : document.querySelector(op) } function getElementForStep(step) { const attachTo = step.options.attachTo; if (!attachTo) return null; const type = typeof attachTo; let element; return element = "string" === type ? getElementFromString(attachTo) : "object" === type ? getElementFromObject(attachTo) : null } function getElementFromString(element) { const _element = element.split(" "), _element = _slicedToArray(_element, 1), selector = _element[0]; return document.querySelector(selector) } function addStepEventListeners() { "function" == typeof this._onScreenChange && (window.removeEventListener("resize", this._onScreenChange, !1), window.removeEventListener("scroll", this._onScreenChange, !0)), window.addEventListener("resize", this._onScreenChange, !1), window.addEventListener("scroll", this._onScreenChange, !0); const overlay = document.querySelector(`#${elementIds.modalOverlay}`); window.addEventListener("touchmove", preventModalBodyTouch, { passive: !1 }), overlay && overlay.addEventListener("touchmove", preventModalOverlayTouch, !1) } var now = function () { return root.Date.now() }, FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min; function debounce(func, wait, options) { var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0; if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT); function invokeFunc(time) { var args = lastArgs, thisArg = lastThis; return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args) } function leadingEdge(time) { return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result } function remainingWait(time) { var timeSinceLastCall, timeSinceLastInvoke, timeWaiting = wait - (time - lastCallTime); return maxing ? nativeMin(timeWaiting, maxWait - (time - lastInvokeTime)) : timeWaiting } function shouldInvoke(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke; return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait } function timerExpired() { var time = now(); if (shouldInvoke(time)) return trailingEdge(time); timerId = setTimeout(timerExpired, remainingWait(time)) } function trailingEdge(time) { return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result) } function cancel() { void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0 } function flush() { return void 0 === timerId ? result : trailingEdge(now()) } function debounced() { var time = now(), isInvoking = shouldInvoke(time); if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) { if (void 0 === timerId) return leadingEdge(lastCallTime); if (maxing) return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime) } return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result } return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxWait = (maxing = "maxWait" in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, debounced.flush = flush, debounced } var FUNC_ERROR_TEXT = "Expected a function"; function baseDelay(func, wait, args) { if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT); return setTimeout(function () { func.apply(void 0, args) }, wait) } function apply(func, thisArg, args) { switch (args.length) { case 0: return func.call(thisArg); case 1: return func.call(thisArg, args[0]); case 2: return func.call(thisArg, args[0], args[1]); case 3: return func.call(thisArg, args[0], args[1], args[2]) }return func.apply(thisArg, args) } var nativeMax = Math.max; function overRest(func, start, transform) { return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function () { for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length;)array[index] = args[start + index]; index = -1; for (var otherArgs = Array(start + 1); ++index < start;)otherArgs[index] = args[index]; return otherArgs[start] = transform(array), apply(func, this, otherArgs) } } function constant(value) { return function () { return value } } var baseSetToString = defineProperty ? function (func, string) { return defineProperty(func, "toString", { configurable: !0, enumerable: !1, value: constant(string), writable: !0 }) } : identity, HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now; function shortOut(func) { var count = 0, lastCalled = 0; return function () { var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled); if (lastCalled = stamp, remaining > 0) { if (++count >= HOT_COUNT) return arguments[0] } else count = 0; return func.apply(void 0, arguments) } } var setToString = shortOut(baseSetToString); function baseRest(func, start) { return setToString(overRest(func, start, identity), func + "") } var defer = baseRest(function (func, args) { return baseDelay(func, 1, args) }); class Modal { constructor(options) { return this._modalOverlayElem || (this._modalOverlayElem = createModalOverlay(), this._modalOverlayOpening = getModalMaskOpening(this._modalOverlayElem), this.hide(), document.body.appendChild(this._modalOverlayElem)), this.options = options, this } cleanup() { defer(() => { const element = this._modalOverlayElem; element && element instanceof SVGElement && element.parentNode.removeChild(element), this._modalOverlayElem = null, document.body.classList.remove(classNames.isVisible) }) } hide() { document.body.classList.remove(classNames.isVisible), this._modalOverlayElem && (this._modalOverlayElem.style.display = "none") } setupForStep(step) { this.options.useModalOverlay ? (this._styleForStep(step), this.show()) : this.hide() } show() { document.body.classList.add(classNames.isVisible), this._modalOverlayElem && (this._modalOverlayElem.style.display = "block") } _styleForStep(step) { const modalOverlayOpening = this._modalOverlayOpening, targetElement = getElementForStep(step); targetElement ? (positionModalOpening(targetElement, modalOverlayOpening), this._onScreenChange = debounce(positionModalOpening.bind(this, targetElement, modalOverlayOpening), 0, { leading: !1, trailing: !0 }), addStepEventListeners.call(this)) : closeModalOpening(this._modalOverlayOpening) } } const defaults = { trigger: "manual", arrow: !0, animation: "fade", duration: 420, flip: !0, animateFill: !1, interactive: !0, hideOnClick: "toggle", multiple: !0 }; function cleanupSteps(tour) { if (tour) { const steps = tour.steps; steps.forEach(step => { if (step.options && !1 === step.options.canClickTarget && step.options.attachTo) { const stepElement = getElementForStep(step); stepElement instanceof HTMLElement && (stepElement.style.pointerEvents = "auto") } }) } } function cleanupStepEventListeners() { "function" == typeof this._onScreenChange && (window.removeEventListener("resize", this._onScreenChange, !1), window.removeEventListener("scroll", this._onScreenChange, !1), this._onScreenChange = null), window.removeEventListener("touchmove", preventModalBodyTouch, { passive: !1 }) } const uniqueId = function () { let id = 0; return function () { return ++id } }(), Shepherd = new Evented; class Tour extends Evented { constructor() { let options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super(options), bindMethods.call(this, ["back", "cancel", "complete", "hide", "next"]), this.options = options, this.steps = this.options.steps || []; const events = ["active", "cancel", "complete", "inactive", "show", "start"]; return events.map(event => { (e => { this.on(e, opts => { (opts = opts || {}).tour = this, Shepherd.trigger(e, opts) }) })(event) }), this.modal = new Modal(options), this._setTooltipDefaults(), this._setTourID(), this } addStep(arg1, arg2) { let name, step; return isUndefined(arg2) ? step = arg1 : (name = arg1, step = arg2), step instanceof Step ? step.tour = this : step = this.setupStep(step, name), this.steps.push(step), step } back() { const index = this.steps.indexOf(this.currentStep); this.show(index - 1, !1) } cancel() { if (this.options.confirmCancel) { const cancelMessage = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?", stopTour = window.confirm(cancelMessage); stopTour && this.done("cancel") } else this.done("cancel") } complete() { this.done("complete") } done(event) { isEmpty(this.steps) || this.steps.forEach(step => step.destroy()), cleanupStepEventListeners.call(this), cleanupSteps(this.tourObject), this.modal.cleanup(), this.trigger(event), Shepherd.activeTour = null, this._removeBodyAttrs(), this.trigger("inactive", { tour: this }) } getById(id) { return this.steps.find(step => step.id === id) } getCurrentStep() { return this.currentStep } hide() { const currentStep = this.getCurrentStep(); if (currentStep) return currentStep.hide() } isActive() { return Shepherd.activeTour === this } next() { const index = this.steps.indexOf(this.currentStep); index === this.steps.length - 1 ? this.complete() : this.show(index + 1, !0) } removeStep(name) { const current = this.getCurrentStep(); this.steps.some((step, i) => { if (step.id === name) return step.isOpen() && step.hide(), step.destroy(), this.steps.splice(i, 1), !0 }), current && current.id === name && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel()) } setupStep(stepOptions, name) { return (isString(name) || isNumber(name)) && (stepOptions.id = name.toString()), stepOptions = Object.assign({}, this.options.defaultStepOptions, stepOptions), new Step(this, stepOptions) } beforeShowStep(step) { this.modal.setupForStep(step), this._styleTargetElementForStep(step) } show() { let key = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, forward = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const step = isString(key) ? this.getById(key) : this.steps[key]; if (step) { this._updateStateBeforeShow(); const shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); shouldSkipStep ? this._skipStep(step, forward) : (this.trigger("show", { step: step, previous: this.currentStep }), this.currentStep = step, step.show()) } } start() { this.trigger("start"), this.currentStep = null, this._setupActiveTour(), addStepEventListeners.call(this), this.next() } _setupActiveTour() { this._addBodyAttrs(), this.trigger("active", { tour: this }), Shepherd.activeTour = this } _styleTargetElementForStep(step) { const targetElement = getElementForStep(step); targetElement && (toggleShepherdModalClass(targetElement), step.options.highlightClass && targetElement.classList.add(step.options.highlightClass), !1 === step.options.canClickTarget && (targetElement.style.pointerEvents = "none")) } _skipStep(step, forward) { const index = this.steps.indexOf(step), nextIndex = forward ? index + 1 : index - 1; this.show(nextIndex, forward) } _setTooltipDefaults() { tippy.setDefaults(defaults) } _updateStateBeforeShow() { this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour() } _setTourID() { const tourName = this.options.tourName || "tour", uuid = uniqueId(); this.id = `--` } _addBodyAttrs() { document.body.setAttribute("data-shepherd-active-tour", this.id), document.body.classList.add("shepherd-active") } _removeBodyAttrs() { document.body.removeAttribute("data-shepherd-active-tour"), document.body.classList.remove("shepherd-active") } } return Object.assign(Shepherd, { Tour: Tour, Step: Step, Evented: Evented }), Shepherd });